<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPIOs &mdash; PyFtdi  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Raleway" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=5929fcd5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="EEPROM management" href="eeprom.html" />
    <link rel="prev" title="FTDI device pinout" href="pinout.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyFtdi
          </a>
              <div class="version">
                0.56.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="urlscheme.html">URL Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pinout.html">FTDI device pinout</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">GPIOs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#other-modes">Other modes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#definitions">Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ports">Ports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gpio-value">GPIO value</a></li>
<li class="toctree-l3"><a class="reference internal" href="#direction">Direction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cbus-gpios">CBUS GPIOs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cbus-eeprom-configuration">CBUS EEPROM configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cbus-gpio-api">CBUS GPIO API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#configuration">Configuration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gpio-bitmap">GPIO bitmap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ft232h-cbus-exception">FT232H CBUS exception</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#direction-bitmap">Direction bitmap</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#direction-example">Direction example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-gpio-apis">Using GPIO APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-gpio-pin-state">Setting GPIO pin state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retrieving-gpio-pin-state">Retrieving GPIO pin state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-gpio-pin-state">Modifying GPIO pin state</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronous-gpio-access">Synchronous GPIO access</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cbus-gpio-access">CBUS GPIO access</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reserved-pins">Reserved pins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gpio-pins-vs-feature-pins">GPIO pins vs. feature pins</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="eeprom.html">EEPROM management</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyFtdi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">GPIOs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/gpio.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="gpios">
<h1>GPIOs<a class="headerlink" href="#gpios" title="Link to this heading"></a></h1>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Many PyFtdi APIs give direct access to the IO pins of the FTDI devices:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>GpioController</em>, implemented as <code class="docutils literal notranslate"><span class="pre">GpioAsyncController</span></code>,
<code class="docutils literal notranslate"><span class="pre">GpioSyncController</span></code> and <code class="docutils literal notranslate"><span class="pre">GpioMpsseController</span></code> (see <a class="reference internal" href="api/gpio.html"><span class="doc">gpio - GPIO API</span></a>)
gives full access to the FTDI pins as raw I/O pins,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SpiGpioPort</span></code> (see <a class="reference internal" href="api/spi.html"><span class="doc">spi - SPI API</span></a>) gives access to all free pins of an
FTDI interface, which are not reserved for the SPI feature,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">I2cGpioPort</span></code> (see <a class="reference internal" href="api/i2c.html"><span class="doc">i2c - I2C API</span></a>) gives access to all free pins of an
FTDI interface, which are not reserved for the I2C feature</p></li>
</ul>
</div></blockquote>
<section id="other-modes">
<h3>Other modes<a class="headerlink" href="#other-modes" title="Link to this heading"></a></h3>
<blockquote>
<div><ul class="simple">
<li><p>Gpio raw access is not yet supported with JTAG feature.</p></li>
<li><p>It is not possible to use GPIO along with UART mode on the same interface.
However, UART mode still provides (very) limited access to GPIO pins, see
UART <a class="reference internal" href="api/uart.html#uart-gpio"><span class="std std-ref">GPIO access</span></a> for details.</p></li>
</ul>
</div></blockquote>
<p>This document presents the common definitions for these APIs and explain how to
drive those pins.</p>
</section>
</section>
<section id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Link to this heading"></a></h2>
<section id="interfaces">
<h3>Interfaces<a class="headerlink" href="#interfaces" title="Link to this heading"></a></h3>
<p>An FTDI <em>interface</em> follows the definition of a <em>USB interface</em>: it is an
independent hardware communication port with an FTDI device. Each interface can
be configured independently from the other interfaces on the same device, e.g.
one interface may be configured as an UART, the other one as I<sup>2</sup>C + GPIO.</p>
<p>It is possible to access two distinct interfaces of the same FTDI device
from a multithreaded application, and even from different applications, or
Python interpreters. However two applications cannot access the same interface
at the same time.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Performing a USB device reset affects all the interfaces of an FTDI device,
this is the rationale for not automatically performing a device reset when
an interface is initialiazed and configured from <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a>.</p>
</div>
</section>
<section id="ports">
<span id="ftdi-ports"></span><h3>Ports<a class="headerlink" href="#ports" title="Link to this heading"></a></h3>
<p>An FTDI port is ofter used in PyFtdi as a synonym for an interface. This may
differ from the FTDI datasheets that sometimes show an interface with several
ports (A*BUS, B*BUS). From a software standpoint, ports and interfaces are
equivalent: APIs access all the HW port from the same interface at once. From a
pure hardware standpoint, a single interface may be depicted as one or two
<em>ports</em>.</p>
<p>With <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a>, <em>ports</em> and <em>interfaces</em> should be considered as synomyms.</p>
<p>Each port can be accessed as raw input/output pins. At a given time, a pin is
either configured as an input or an output function.</p>
<p>The width of a port, that is the number of pins of the interface, depending on
the actual hardware, <em>i.e.</em> the FTDI model:</p>
<ul class="simple">
<li><p>FT232R features a single port, which is 8-bit wide: <cite>DBUS</cite>,</p></li>
<li><p>FT232H features a single port, which is 16-bit wide: <cite>ADBUS/ACBUS</cite>,</p></li>
<li><p>FT2232D features two ports, which are 12-bit wide each: <cite>ADBUS/ACBUS</cite> and
<cite>BDBUS/BCBUS</cite>,</p></li>
<li><p>FT2232H features two ports, which are 16-bit wide each: <cite>ADBUS/ACBUS</cite> and
<cite>BDBUS/BCBUS</cite>,</p></li>
<li><p>FT4232H/FT4232HA features four ports, which are 8-bit wide each: <cite>ADBUS</cite>,
<cite>BDBUS</cite>, <cite>CDBUS</cite> and <cite>DDBUS</cite>,</p></li>
<li><p>FT230X features a single port, which is 4-bit wide,</p></li>
<li><p>FT231X feature a single port, which is 8-bit wide</p></li>
</ul>
<p>For historical reasons, 16-bit ports used to be named <em>wide</em> ports and 8-bit
ports used to be called <em>narrow</em> with <a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a>. This terminology and APIs are
no longer used, but are kept to prevent API break. Please only use the port
<code class="docutils literal notranslate"><span class="pre">width</span></code> rather than these legacy port types.</p>
</section>
<section id="gpio-value">
<h3>GPIO value<a class="headerlink" href="#gpio-value" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>A logical <code class="docutils literal notranslate"><span class="pre">0</span></code> bit represents a low level value on a pin, that is <em>GND</em></p></li>
<li><p>A logical <code class="docutils literal notranslate"><span class="pre">1</span></code> bit represents a high level value on a pin, that is <em>Vdd</em>
which is typically 3.3 volts on most FTDIs</p></li>
</ul>
<p>Please refers to the FTDI datasheet of your device for the tolerance and
supported analog levels for more details</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>FT232H supports a specific feature, which is dedicated to better supporting
the I<sup>2</sup>C feature. This specific devices enables an open-collector mode:</p>
<ul class="simple">
<li><p>Setting a pin to a low level drains it to <em>GND</em></p></li>
<li><p>Setting a pin to a high level sets the pin as High-Z</p></li>
</ul>
<p>This feature is automatically activated when I<sup>2</sup>C feature is enabled on a
port, for the two first pins, i.e. <cite>SCL</cite> and <cite>SDA out</cite>.</p>
<p>However, PyFTDI does not yet provide an API to enable this mode to the
other pins of a port, <em>i.e.</em> for the pins used as GPIOs.</p>
</div>
</section>
<section id="direction">
<h3>Direction<a class="headerlink" href="#direction" title="Link to this heading"></a></h3>
<p>An FTDI pin should either be configured as an input or an ouput. It is
mandatory to (re)configure the direction of a pin before changing the way it is
used.</p>
<ul class="simple">
<li><p>A logical <code class="docutils literal notranslate"><span class="pre">0</span></code> bit represents an input pin, <em>i.e.</em> a pin whose value can be
sampled and read via the PyFTDI APIs</p></li>
<li><p>A logical <code class="docutils literal notranslate"><span class="pre">1</span></code> bit represents an output pin, <em>i.e.</em> a pin whose value can be
set/written with the PyFTDI APIs</p></li>
</ul>
</section>
</section>
<section id="cbus-gpios">
<span id="cbus-gpio"></span><h2>CBUS GPIOs<a class="headerlink" href="#cbus-gpios" title="Link to this heading"></a></h2>
<p>FT232R, FT232H and FT230X/FT231X support an additional port denoted CBUS:</p>
<ul class="simple">
<li><p>FT232R provides an additional 5-bit wide port, where only 4 LSBs can be
used as programmable GPIOs: <code class="docutils literal notranslate"><span class="pre">CBUS0</span></code> to <code class="docutils literal notranslate"><span class="pre">CBUS3</span></code>,</p></li>
<li><p>FT232H provices an additional 10-bit wide port, where only 4 pins can be
used as programmable GPIOs: <code class="docutils literal notranslate"><span class="pre">CBUS5</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS6</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS8</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS9</span></code></p></li>
<li><p>FT230X/FT231X provides an additional 4-bit wide port: <code class="docutils literal notranslate"><span class="pre">CBUS0</span></code> to <code class="docutils literal notranslate"><span class="pre">CBUS3</span></code></p></li>
</ul>
<p>Note that CBUS access is slower than regular asynchronous bitbang mode.</p>
<section id="cbus-eeprom-configuration">
<h3>CBUS EEPROM configuration<a class="headerlink" href="#cbus-eeprom-configuration" title="Link to this heading"></a></h3>
<p>Accessing this extra port requires a specific EEPROM configuration.</p>
<p>The EEPROM needs to be configured so that the CBUS pins that need to be used
as GPIOs are defined as <code class="docutils literal notranslate"><span class="pre">GPIO</span></code>. Without this special configuration, CBUS
pins are used for other functions, such as driving leds when data is exchanged
over the UART port. Remember to power-cycle the FTDI device after changing its
EEPROM configuration to force load the new configuration.</p>
<p>The <a class="reference internal" href="eeprom.html#ftconf"><span class="std std-ref">EEPROM configuration tool</span></a> tool can be used to query and change the EEPROM
configuration. See the EEPROM configuration <a class="reference internal" href="eeprom.html#eeprom-cbus"><span class="std std-ref">example</span></a>.</p>
</section>
<section id="cbus-gpio-api">
<h3>CBUS GPIO API<a class="headerlink" href="#cbus-gpio-api" title="Link to this heading"></a></h3>
<p><a class="reference external" href="https://www.github.com/eblot/pyftdi">PyFtdi</a> starting from v0.47 supports CBUS pins as special GPIO port. This port
is <em>not</em> mapped as regular GPIO, a dedicated API is reserved to drive those
pins:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api/ftdi.html#pyftdi.ftdi.Ftdi.has_cbus" title="pyftdi.ftdi.Ftdi.has_cbus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyftdi.ftdi.Ftdi.has_cbus()</span></code></a> to report whether the device supports
CBUS gpios,</p></li>
<li><p><a class="reference internal" href="api/ftdi.html#pyftdi.ftdi.Ftdi.set_cbus_direction" title="pyftdi.ftdi.Ftdi.set_cbus_direction"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyftdi.ftdi.Ftdi.set_cbus_direction()</span></code></a> to configure the port,</p></li>
<li><p><a class="reference internal" href="api/ftdi.html#pyftdi.ftdi.Ftdi.get_cbus_gpio" title="pyftdi.ftdi.Ftdi.get_cbus_gpio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyftdi.ftdi.Ftdi.get_cbus_gpio()</span></code></a> to get the logical values from the
port,</p></li>
<li><p><a class="reference internal" href="api/ftdi.html#pyftdi.ftdi.Ftdi.set_cbus_gpio" title="pyftdi.ftdi.Ftdi.set_cbus_gpio"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyftdi.ftdi.Ftdi.set_cbus_gpio()</span></code></a> to set new logical values to the
port</p></li>
</ul>
<p>Additionally, the EEPROM configuration can be queried to retrieve which CBUS
pins have been assigned to GPIO functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api/eeprom.html#pyftdi.eeprom.FtdiEeprom.cbus_pins" title="pyftdi.eeprom.FtdiEeprom.cbus_pins"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pyftdi.eeprom.FtdiEeprom.cbus_pins()</span></code></a> to report CBUS GPIO pins</p></li>
</ul>
<p>The CBUS port is <strong>not</strong> available through the
<code class="xref py py-class docutils literal notranslate"><span class="pre">pyftdi.gpio.GpioController</span></code> API, as it cannot be considered as a
regular GPIO port.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>CBUS GPIO feature has only be tested with the virtual test framework and a
real FT231X HW device. It should be considered as an experimental feature
for now.</p>
</div>
</section>
</section>
<section id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Link to this heading"></a></h2>
<section id="gpio-bitmap">
<h3>GPIO bitmap<a class="headerlink" href="#gpio-bitmap" title="Link to this heading"></a></h3>
<p>The GPIO pins of a port are always accessed as an integer, whose supported
width depends on the width of the port. These integers should be considered as
a bitmap of pins, and are always assigned the same mapping, whatever feature is
enabled:</p>
<ul class="simple">
<li><p>b<sub>0</sub> (<code class="docutils literal notranslate"><span class="pre">0x01</span></code>) represents the first pin of a port, <em>i.e.</em> AD0/BD0</p></li>
<li><p>b<sub>1</sub> (<code class="docutils literal notranslate"><span class="pre">0x02</span></code>) represents the second pin of a port, <em>i.e.</em> AD1/BD1</p></li>
<li><p>…</p></li>
<li><p>b<sub>7</sub> (<code class="docutils literal notranslate"><span class="pre">0x80</span></code>) represents the eighth pin of a port, <em>i.e.</em> AD7/BD7</p></li>
<li><p>b<sub>N</sub> represents the highest pin of a port, <em>i.e.</em> AD7/BD7 for an
8-bit port, AD15/BD15 for a 16-bit port, etc.</p></li>
</ul>
<p>Pins reserved for a specific feature (I<sup>2</sup>C, SPI, …) cannot be accessed as
a regular GPIO. They cannot be arbitrarily written and should be masked out
when the GPIO output value is set. See <a class="reference internal" href="#reserved-pins"><span class="std std-ref">Reserved pins</span></a> for details.</p>
<section id="ft232h-cbus-exception">
<h4>FT232H CBUS exception<a class="headerlink" href="#ft232h-cbus-exception" title="Link to this heading"></a></h4>
<p>Note that there is an exception to this rule for FT232H CBUS port: FTDI has
decided to map non-contiguous CBUS pins as GPIO-capable CBUS pins, that is
<code class="docutils literal notranslate"><span class="pre">CBUS5</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS6</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS8</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS9</span></code>, where other CBUS-enabled devices
use <code class="docutils literal notranslate"><span class="pre">CBUS0</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS1</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS2</span></code>, <code class="docutils literal notranslate"><span class="pre">CBUS3</span></code>.</p>
<p>If the CBUS GPIO feature is used with an FT232H device, the pin positions for
the GPIO port are not b<sub>5</sub> .. b<sub>9</sub> but b<sub>0</sub> to
b<sub>3</sub> . This may sounds weird, but CBUS feature is somewhat hack-ish
even with FTDI commands, so it did not deserve a special treatment for the sake
of handling the weird implementation of FT232H.</p>
</section>
</section>
<section id="direction-bitmap">
<h3>Direction bitmap<a class="headerlink" href="#direction-bitmap" title="Link to this heading"></a></h3>
<p>Before using a port as GPIO, the port must be configured as GPIO. This is
achieved by either instanciating one of the <em>GpioController</em> or by requesting
the GPIO port from a specific serial bus controller:
<code class="docutils literal notranslate"><span class="pre">I2cController.get_gpio()</span></code> and <code class="docutils literal notranslate"><span class="pre">SpiController.get_gpio()</span></code>. All instances
provide a similar API (duck typing API) to configure, read and write to GPIO
pins.</p>
<p>Once a GPIO port is instanciated, the direction of each pin should be defined.
The direction can be changed at any time. It is not possible to write to /
read from a pin before the proper direction has been defined.</p>
<p>To configure the direction, use the <cite>set_direction</cite> API with a bitmap integer
value that defines the direction to use of each pin.</p>
<section id="direction-example">
<h4>Direction example<a class="headerlink" href="#direction-example" title="Link to this heading"></a></h4>
<p>A 8-bit port, dedicated to GPIO, is configured as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>BD0, BD3, BD7: input, <cite>I</cite> for short</p></li>
<li><p>BD1-BD2, BD4-BD6: output, <cite>O</cite> for short</p></li>
</ul>
</div></blockquote>
<p>That is, MSB to LSB: <em>I O O O I O O I</em>.</p>
<p>This translates to 0b <code class="docutils literal notranslate"><span class="pre">0111</span> <span class="pre">0110</span></code> as output is <code class="docutils literal notranslate"><span class="pre">1</span></code> and input is <code class="docutils literal notranslate"><span class="pre">0</span></code>,
that is <code class="docutils literal notranslate"><span class="pre">0x76</span></code> as an hexa value. This is the direction value to use to
<code class="docutils literal notranslate"><span class="pre">configure()</span></code> the port.</p>
<p>See also the <code class="docutils literal notranslate"><span class="pre">set_direction()</span></code> API to reconfigure the direction of GPIO pins
at any time. This method accepts two arguments. This first arguments,
<code class="docutils literal notranslate"><span class="pre">pins</span></code>, defines which pins - the ones with the maching bit set - to consider
in the second <code class="docutils literal notranslate"><span class="pre">direction</span></code> argument, so there is no need to
preserve/read-modify-copy the configuration of other pins. Pins with their
matching bit reset are not reconfigured, whatever their direction bit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpio</span> <span class="o">=</span> <span class="n">GpioAsyncController</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x76</span><span class="p">)</span>
<span class="c1"># later, reconfigure BD2 as input and BD7 as output</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">set_direction</span><span class="p">(</span><span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="using-gpio-apis">
<h2>Using GPIO APIs<a class="headerlink" href="#using-gpio-apis" title="Link to this heading"></a></h2>
<p>There are 3 variant of <em>GpioController</em>, depending on which features are needed
and how the GPIO port usage is intended. <a class="reference internal" href="api/gpio.html"><span class="doc">gpio - GPIO API</span></a> gives in depth details
about those controllers. Those controllers are mapped onto FTDI HW features.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">GpioAsyncController</span></code> is likely the most useful API to drive GPIOs.</p>
<p>It enables reading current GPIO input pin levels and to change GPIO output
pin levels. When vector values (byte buffers) are used instead of scalar
value (single byte), GPIO pins are samples/updated at a regular pace, whose
frequency can be configured. It is however impossible to control the exact
time when input pins start to be sampled, which can be tricky to use with
most applications. See <a class="reference internal" href="api/gpio.html"><span class="doc">gpio - GPIO API</span></a> for details.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">GpioSyncController</span></code> is a variant of the previous API.</p>
<p>It is aimed at precise time control of sampling/updating the GPIO: a new
GPIO input sample is captured once every time GPIO output pins are updated.
With byte buffers, GPIO pins are samples/updated at a regular pace, whose
frequency can be configured as well. The API of <code class="docutils literal notranslate"><span class="pre">GpioSyncController</span></code>
slightly differ from the other GPIO APIs, as the usual <code class="docutils literal notranslate"><span class="pre">read</span></code>/<code class="docutils literal notranslate"><span class="pre">write</span></code>
method are replaced with a single <code class="docutils literal notranslate"><span class="pre">exchange</span></code> method.</p>
</li>
</ul>
<p>Both <code class="docutils literal notranslate"><span class="pre">GpioAsyncController</span></code> and <code class="docutils literal notranslate"><span class="pre">GpioSyncController</span></code> are restricted to only
access the 8 LSB pins of a port, which means that FTDI device with wider port
(12- and 16- pins) cannot be fully addressed, as only b<sub>0</sub> to b<sub>7</sub> can be addressed.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">GpioMpsseController</span></code> enables access to the MSB pins of wide ports.</p>
<p>However LSB and MSB pins cannot be addressed in a true atomic manner, which
means that there is a short delay between sampling/updating the LSB and MSB
part of the same wide port. Byte buffer can also be sampled/updated at a
regular pace, but the achievable frequency range may differ from the other
controllers.</p>
</li>
</ul>
<p>It is recommened to read the <code class="docutils literal notranslate"><span class="pre">tests/gpio.py</span></code> files - available from GitHub -
to get some examples on how to use these API variants.</p>
<section id="setting-gpio-pin-state">
<h3>Setting GPIO pin state<a class="headerlink" href="#setting-gpio-pin-state" title="Link to this heading"></a></h3>
<p>To write to a GPIO, use the <cite>write()</cite> method. The caller needs to mask out
the bits configured as input, or an exception is triggered:</p>
<ul class="simple">
<li><p>writing <code class="docutils literal notranslate"><span class="pre">0</span></code> to an input pin is ignored</p></li>
<li><p>writing <code class="docutils literal notranslate"><span class="pre">1</span></code> to an input pin raises an exception</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpio</span> <span class="o">=</span> <span class="n">GpioAsyncController</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x76</span><span class="p">)</span>
<span class="c1"># all output set low</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span>
<span class="c1"># all output set high</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x76</span><span class="p">)</span>
<span class="c1"># all output set high, apply direction mask</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="n">gpio</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span>
<span class="c1"># all output forced to high, writing to input pins is illegal</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">)</span>  <span class="c1"># raises an IOError</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="retrieving-gpio-pin-state">
<h3>Retrieving GPIO pin state<a class="headerlink" href="#retrieving-gpio-pin-state" title="Link to this heading"></a></h3>
<p>To read a GPIO, use the <cite>read()</cite> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpio</span> <span class="o">=</span> <span class="n">GpioAsyncController</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x76</span><span class="p">)</span>
<span class="c1"># read whole port</span>
<span class="n">pins</span> <span class="o">=</span> <span class="n">gpio</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="c1"># ignore output values (optional)</span>
<span class="n">pins</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">gpio</span><span class="o">.</span><span class="n">direction</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="modifying-gpio-pin-state">
<h3>Modifying GPIO pin state<a class="headerlink" href="#modifying-gpio-pin-state" title="Link to this heading"></a></h3>
<p>A read-modify-write sequence is required.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpio</span> <span class="o">=</span> <span class="n">GpioAsyncController</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x76</span><span class="p">)</span>
<span class="c1"># read whole port</span>
<span class="n">pins</span> <span class="o">=</span> <span class="n">gpio</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="c1"># clearing out AD1 and AD2</span>
<span class="n">pins</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># or 0x06</span>
<span class="c1"># want AD2=0, AD1=1</span>
<span class="n">pins</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="c1"># update GPIO output</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pins</span><span class="p">)</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="synchronous-gpio-access">
<h3>Synchronous GPIO access<a class="headerlink" href="#synchronous-gpio-access" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gpio</span> <span class="o">=</span> <span class="n">GpioSyncController</span><span class="p">()</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x0F</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)</span>
<span class="n">outs</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">gpio</span><span class="o">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>
<span class="c1"># ins contains as many bytes as outs</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="cbus-gpio-access">
<h3>CBUS GPIO access<a class="headerlink" href="#cbus-gpio-access" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ftdi</span> <span class="o">=</span> <span class="n">Ftdi</span><span class="p">()</span>
<span class="n">ftdi</span><span class="o">.</span><span class="n">open_from_url</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">)</span>
<span class="c1"># validate CBUS feature with the current device</span>
<span class="k">assert</span> <span class="n">ftdi</span><span class="o">.</span><span class="n">has_cbus</span>
<span class="c1"># validate CBUS EEPROM configuration with the current device</span>
<span class="n">eeprom</span> <span class="o">=</span> <span class="n">FtdiEeprom</span><span class="p">()</span>
<span class="n">eeprom</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ftdi</span><span class="p">)</span>
<span class="c1"># here we use CBUS0 and CBUS3 (or CBUS5 and CBUS9 on FT232H)</span>
<span class="k">assert</span> <span class="n">eeprom</span><span class="o">.</span><span class="n">cbus_mask</span> <span class="o">&amp;</span> <span class="mb">0b1001</span> <span class="o">==</span> <span class="mb">0b1001</span>
<span class="c1"># configure CBUS0 as output and CBUS3 as input</span>
<span class="n">ftdi</span><span class="o">.</span><span class="n">set_cbus_direction</span><span class="p">(</span><span class="mb">0b1001</span><span class="p">,</span> <span class="mb">0b0001</span><span class="p">)</span>
<span class="c1"># set CBUS0</span>
<span class="n">ftdi</span><span class="o">.</span><span class="n">set_cbus_gpio</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span>
<span class="c1"># get CBUS3</span>
<span class="n">cbus3</span> <span class="o">=</span> <span class="n">ftdi</span><span class="o">.</span><span class="n">get_cbus_gpio</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># it is possible to open the ftdi object from an existing serial connection:</span>
<span class="n">port</span> <span class="o">=</span> <span class="n">serial_for_url</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">)</span>
<span class="n">ftdi</span> <span class="o">=</span> <span class="n">port</span><span class="o">.</span><span class="n">ftdi</span>
<span class="n">ftdi</span><span class="o">.</span><span class="n">has_cbus</span>
<span class="c1"># etc...</span>
</pre></div>
</div>
</section>
</section>
<section id="reserved-pins">
<span id="id1"></span><h2>Reserved pins<a class="headerlink" href="#reserved-pins" title="Link to this heading"></a></h2>
<section id="gpio-pins-vs-feature-pins">
<h3>GPIO pins vs. feature pins<a class="headerlink" href="#gpio-pins-vs-feature-pins" title="Link to this heading"></a></h3>
<p>It is important to note that the reserved pins do not change the pin
assignment, <em>i.e.</em> the lowest pins of a port may become unavailable as regular
GPIO when the feature is enabled:</p>
<section id="example">
<h4>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h4>
<p>I<sup>2</sup>C feature reserves
the three first pins, as <em>SCL</em>, <em>SDA output</em>, <em>SDA input</em> (w/o clock stretching
feature which also reserves another pin). This means that AD0, AD1 and AD2,
that is b<sub>0</sub>, b<sub>1</sub>, b<sub>2</sub> cannot be directly
accessed.</p>
<p>The first accessible GPIO pin in this case is no longer AD0 but AD3, which
means that b<sub>3</sub>becomes the lowest bit which can be read/written.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># use I2C feature</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2cController</span><span class="p">()</span>
<span class="c1"># configure the I2C feature, and predefines the direction of the GPIO pins</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span><span class="s1">&#39;ftdi:///1&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mh">0x78</span><span class="p">)</span>
<span class="n">gpio</span> <span class="o">=</span> <span class="n">i2c</span><span class="o">.</span><span class="n">get_gpio</span><span class="p">()</span>
<span class="c1"># read whole port</span>
<span class="n">pins</span> <span class="o">=</span> <span class="n">gpio</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="c1"># clearing out I2C bits (SCL, SDAo, SDAi)</span>
<span class="n">pins</span> <span class="o">&amp;=</span> <span class="mh">0x07</span>
<span class="c1"># set AD4</span>
<span class="n">pins</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="c1"># update GPIO output</span>
<span class="n">gpio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pins</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pinout.html" class="btn btn-neutral float-left" title="FTDI device pinout" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="eeprom.html" class="btn btn-neutral float-right" title="EEPROM management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2010-2024, Emmanuel Blot &lt;emmanuel.blot@free.fr&gt;.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>