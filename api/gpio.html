

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gpio - GPIO API &mdash; PyFtdi  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Raleway" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="i2c - I2C API" href="i2c.html" />
    <link rel="prev" title="ftdi - FTDI low-level driver" href="ftdi.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PyFtdi
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../urlscheme.html">URL Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#release"></a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ftdi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftdi</span></code> - FTDI low-level driver</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#info-about-gpio-api">Info about GPIO API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">i2c</span></code> - I<sup>2</sup>C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spi</span></code> - SPI API</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">serialext</span></code> - UART API</a></li>
<li class="toctree-l3"><a class="reference internal" href="usbtools.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">usbtools</span></code> - USB tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="misc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">misc</span></code> - Miscellaneous helpers</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeprom.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">eeprom</span></code> - EEPROM API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pinout.html">FTDI device pinout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpio.html">GPIOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eeprom.html">EEPROM management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyFtdi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">API documentation</a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/gpio.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pyftdi.gpio">
<span id="gpio-gpio-api"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">gpio</span></code> - GPIO API<a class="headerlink" href="#module-pyftdi.gpio" title="Link to this heading"></a></h1>
<p>Direct drive GPIO pins of FTDI device.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This mode is mutually exclusive with advanced serial MPSSE features, such as
I<sup>2</sup>C, SPI, JTAG, …</p>
<p>If you need to use GPIO pins and MPSSE interface on the same port, you need
to use the dedicated API. This shared mode is supported with the
<a class="reference internal" href="spi.html"><span class="doc">SPI API</span></a> and the <a class="reference internal" href="i2c.html"><span class="doc">I2C API</span></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API does not provide access to the special CBUS port of FT232R, FT232H,
FT230X and FT231X devices. See <a class="reference internal" href="../gpio.html#cbus-gpio"><span class="std std-ref">CBUS GPIOs</span></a> for details.</p>
</div>
<section id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Link to this heading"></a></h2>
<p>See <code class="docutils literal notranslate"><span class="pre">tests/gpio.py</span></code> example</p>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioPort">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyftdi.gpio.</span></span><span class="sig-name descname"><span class="pre">GpioPort</span></span><a class="headerlink" href="#pyftdi.gpio.GpioPort" title="Link to this definition"></a></dt>
<dd><p>Duck-type GPIO port for GPIO all controllers.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyftdi.gpio.</span></span><span class="sig-name descname"><span class="pre">GpioAsyncController</span></span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController" title="Link to this definition"></a></dt>
<dd><p>GPIO controller for an FTDI port, in bit-bang asynchronous mode.</p>
<p>GPIO accessible pins are limited to the 8 lower pins of each GPIO port.</p>
<p>Asynchronous bitbang output are updated on write request using the
<a class="reference internal" href="#pyftdi.gpio.GpioAsyncController.write" title="pyftdi.gpio.GpioAsyncController.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> method, clocked at the selected frequency.</p>
<p>Asynchronous bitbang input are sampled at the same rate, as soon as the
controller is initialized. The GPIO input samples fill in the FTDI HW
buffer until it is filled up, in which case sampling stops until the
GPIO samples are read out with the <a class="reference internal" href="#pyftdi.gpio.GpioAsyncController.read" title="pyftdi.gpio.GpioAsyncController.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> method. It may be
therefore hard to use, except if peek mode is selected,
see <a class="reference internal" href="#pyftdi.gpio.GpioAsyncController.read" title="pyftdi.gpio.GpioAsyncController.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> for details.</p>
<p>Note that FTDI internal clock divider cannot generate any arbitrary
frequency, so the closest frequency to the request one that can be
generated is selected. The actual <code class="xref py py-attr docutils literal notranslate"><span class="pre">frequency</span></code> may be tested to
check if it matches the board requirements.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.open_from_url">
<span class="sig-name descname"><span class="pre">open_from_url</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">url</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.open_from_url" title="Link to this definition"></a></dt>
<dd><p>Open a new interface to the specified FTDI device in bitbang mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>url</strong> (<em>str</em>) – a FTDI URL selector</p></li>
<li><p><strong>direction</strong> (<em>int</em>) – a bitfield specifying the FTDI GPIO direction,
where high level defines an output, and low level defines an
input</p></li>
<li><p><strong>initial</strong> – optional initial GPIO output value</p></li>
<li><p><strong>pace</strong> – optional pace in GPIO sample per second</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>actual bitbang pace in sample per second</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">readlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peek</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noflush</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.read" title="Link to this definition"></a></dt>
<dd><p>Read the GPIO input pin electrical level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>readlen</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – how many GPIO samples to retrieve. Each sample is
8-bit wide.</p></li>
<li><p><strong>peek</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]</span>) – whether to peek/sample the instantaneous GPIO pin
values from port, or to use the HW FIFO. The HW FIFO is
continously filled up with GPIO sample at the current
frequency, until it is full - samples are no longer
collected until the FIFO is read. This means than
non-peek mode read “old” values, with no way to know at
which time they have been sampled. PyFtdi ensures that
old sampled values before the completion of a previous
GPIO write are discarded. When peek mode is selected,
readlen should be 1.</p></li>
<li><p><strong>noflush</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – whether to disable the RX buffer flush before
reading out data</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a 8-bit wide integer if peek mode is used, or
a bytes buffer otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.read_port">
<span class="sig-name descname"><span class="pre">read_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">readlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peek</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noflush</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.read_port" title="Link to this definition"></a></dt>
<dd><p>Read the GPIO input pin electrical level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>readlen</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – how many GPIO samples to retrieve. Each sample is
8-bit wide.</p></li>
<li><p><strong>peek</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]</span>) – whether to peek/sample the instantaneous GPIO pin
values from port, or to use the HW FIFO. The HW FIFO is
continously filled up with GPIO sample at the current
frequency, until it is full - samples are no longer
collected until the FIFO is read. This means than
non-peek mode read “old” values, with no way to know at
which time they have been sampled. PyFtdi ensures that
old sampled values before the completion of a previous
GPIO write are discarded. When peek mode is selected,
readlen should be 1.</p></li>
<li><p><strong>noflush</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></span>) – whether to disable the RX buffer flush before
reading out data</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a 8-bit wide integer if peek mode is used, or
a bytes buffer otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.set_frequency">
<span class="sig-name descname"><span class="pre">set_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.set_frequency" title="Link to this definition"></a></dt>
<dd><p>Set the frequency at which sequence of GPIO samples are read
and written.</p>
<p>note: FTDI may update its clock register before it has emptied its
internal buffer. If the current frequency is “low”, some
yet-to-output bytes may end up being clocked at the new frequency.</p>
<p>Unfortunately, it seems there is no way to wait for the internal
buffer to be emptied out. They can be flushed (i.e. discarded), but
not synchronized :-(</p>
<p>PyFtdi client should add “some” short delay to ensure a previous,
long write request has been fully output &#64; low freq before changing
the frequency.</p>
<p>Beware that only some exact frequencies can be generated. Contrary
to the UART mode, an approximate frequency is always accepted for
GPIO/bitbang mode. To get the actual frequency, and optionally abort
if it is out-of-spec, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">frequency()</span></code> property.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>frequency</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) – the new frequency, in GPIO samples per second</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.write" title="Link to this definition"></a></dt>
<dd><p>Set the GPIO output pin electrical level, or output a sequence of
bytes &#64; constant frequency to GPIO output pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>out</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – a bitfield of GPIO pins, or a sequence of them</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioAsyncController.write_port">
<span class="sig-name descname"><span class="pre">write_port</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioAsyncController.write_port" title="Link to this definition"></a></dt>
<dd><p>Set the GPIO output pin electrical level, or output a sequence of
bytes &#64; constant frequency to GPIO output pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>out</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – a bitfield of GPIO pins, or a sequence of them</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioSyncController">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyftdi.gpio.</span></span><span class="sig-name descname"><span class="pre">GpioSyncController</span></span><a class="headerlink" href="#pyftdi.gpio.GpioSyncController" title="Link to this definition"></a></dt>
<dd><p>GPIO controller for an FTDI port, in bit-bang synchronous mode.</p>
<p>GPIO accessible pins are limited to the 8 lower pins of each GPIO port.</p>
<p>Synchronous bitbang input and output are synchronized. Eveery time GPIO
output is updated, the GPIO input is sampled and buffered.</p>
<p>Update and sampling are clocked at the selected frequency. The GPIO
samples are transfer in both direction with the <a class="reference internal" href="#pyftdi.gpio.GpioSyncController.exchange" title="pyftdi.gpio.GpioSyncController.exchange"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exchange()</span></code></a>
method, which therefore always returns as many input samples as output
bytes.</p>
<p>Note that FTDI internal clock divider cannot generate any arbitrary
frequency, so the closest frequency to the request one that can be
generated is selected. The actual <code class="xref py py-attr docutils literal notranslate"><span class="pre">frequency</span></code> may be tested to
check if it matches the board requirements.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioSyncController.exchange">
<span class="sig-name descname"><span class="pre">exchange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioSyncController.exchange" title="Link to this definition"></a></dt>
<dd><p>Set the GPIO output pin electrical level, or output a sequence of
bytes &#64; constant frequency to GPIO output pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>out</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>]</span>) – the byte buffer to output as GPIO</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a byte buffer of the same length as out buffer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioSyncController.set_frequency">
<span class="sig-name descname"><span class="pre">set_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioSyncController.set_frequency" title="Link to this definition"></a></dt>
<dd><p>Set the frequency at which sequence of GPIO samples are read
and written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>frequency</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) – the new frequency, in GPIO samples per second</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioMpsseController">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyftdi.gpio.</span></span><span class="sig-name descname"><span class="pre">GpioMpsseController</span></span><a class="headerlink" href="#pyftdi.gpio.GpioMpsseController" title="Link to this definition"></a></dt>
<dd><p>GPIO controller for an FTDI port, in MPSSE mode.</p>
<p>All GPIO pins are reachable, but MPSSE mode is slower than other modes.</p>
<p>Beware that LSBs (b0..b7) and MSBs (b8..b15) are accessed with two
subsequence commands, so a slight delay may occur when sampling or
changing both groups at once. In other word, it is not possible to
atomically read to / write from LSBs and MSBs. This might be worth
checking the board design if atomic access to several lines is required.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioMpsseController.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">readlen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peek</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioMpsseController.read" title="Link to this definition"></a></dt>
<dd><p>Read the GPIO input pin electrical level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>readlen</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></span>) – how many GPIO samples to retrieve. Each sample if
<code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code> bit wide.</p></li>
<li><p><strong>peek</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]</span>) – whether to peak current value from port, or to use
MPSSE stream and HW FIFO. When peek mode is selected,
readlen should be 1. It is not available with wide
ports if some of the MSB pins are configured as input</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a <code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code> bit wide integer if direct mode is used,
a bytes buffer if <code class="xref py py-meth docutils literal notranslate"><span class="pre">width()</span></code> is a byte,
a list of integer otherwise (MPSSE mode only).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioMpsseController.set_frequency">
<span class="sig-name descname"><span class="pre">set_frequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioMpsseController.set_frequency" title="Link to this definition"></a></dt>
<dd><p>Set the frequency at which sequence of GPIO samples are read
and written.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>frequency</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</span>) – the new frequency, in GPIO samples per second</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioMpsseController.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyftdi.gpio.GpioMpsseController.write" title="Link to this definition"></a></dt>
<dd><p>Set the GPIO output pin electrical level, or output a sequence of
bytes &#64; constant frequency to GPIO output pins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>out</strong> (<span class="sphinx_autodoc_typehints-type"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</span>) – a bitfield of GPIO pins, or a sequence of them</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></span></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Link to this heading"></a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="pyftdi.gpio.GpioException">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyftdi.gpio.</span></span><span class="sig-name descname"><span class="pre">GpioException</span></span><a class="headerlink" href="#pyftdi.gpio.GpioException" title="Link to this definition"></a></dt>
<dd><p>Base class for GPIO errors.</p>
</dd></dl>

</section>
<section id="info-about-gpio-api">
<h2>Info about GPIO API<a class="headerlink" href="#info-about-gpio-api" title="Link to this heading"></a></h2>
<p>See <a class="reference internal" href="../gpio.html"><span class="doc">GPIOs</span></a> for details</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ftdi.html" class="btn btn-neutral float-left" title="ftdi - FTDI low-level driver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="i2c.html" class="btn btn-neutral float-right" title="i2c - I2C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2010-2024, Emmanuel Blot &lt;emmanuel.blot@free.fr&gt;.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>